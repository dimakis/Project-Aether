"""Insight repository for Data Science team analysis results.

User Story 3: Energy Optimization Suggestions.

Provides CRUD operations for managing insights generated
by the Data Science team's energy analysis.
"""

from datetime import UTC, datetime, timedelta
from typing import Any
from uuid import uuid4

from sqlalchemy import func, select
from sqlalchemy.ext.asyncio import AsyncSession

from src.storage.entities.insight import Insight, InsightStatus, InsightType


class InsightRepository:
    """Repository for Insight CRUD operations.

    Manages insights generated by the Data Science team,
    including energy optimizations, anomaly detections, and usage patterns.
    """

    def __init__(self, session: AsyncSession):
        """Initialize repository with database session.

        Args:
            session: SQLAlchemy async session
        """
        self.session = session

    async def create(
        self,
        type: InsightType,
        title: str,
        description: str,
        evidence: dict[str, Any],
        confidence: float,
        impact: str,
        entities: list[str] | None = None,
        script_path: str | None = None,
        script_output: dict[str, Any] | None = None,
        mlflow_run_id: str | None = None,
        conversation_id: str | None = None,
        task_label: str | None = None,
    ) -> Insight:
        """Create a new insight.

        Args:
            type: Insight category (energy_optimization, anomaly, etc.)
            title: Brief summary
            description: Detailed explanation (markdown supported)
            evidence: Supporting data (charts, statistics, queries)
            confidence: Confidence score 0.0-1.0
            impact: Potential impact level (low, medium, high, critical)
            entities: Related entity IDs
            script_path: Path to the analysis script (in MLflow artifacts)
            script_output: Script execution results
            mlflow_run_id: MLflow run ID for traceability
            conversation_id: Originating conversation ID
            task_label: Human-readable task label

        Returns:
            Created Insight
        """
        insight = Insight(
            id=str(uuid4()),
            type=type,
            title=title,
            description=description,
            evidence=evidence,
            confidence=confidence,
            impact=impact,
            entities=entities or [],
            script_path=script_path,
            script_output=script_output,
            status=InsightStatus.PENDING,
            mlflow_run_id=mlflow_run_id,
            conversation_id=conversation_id,
            task_label=task_label,
        )
        self.session.add(insight)
        await self.session.flush()
        return insight

    async def get_by_id(self, insight_id: str) -> Insight | None:
        """Get insight by ID.

        Args:
            insight_id: Insight UUID

        Returns:
            Insight or None
        """
        result = await self.session.execute(select(Insight).where(Insight.id == insight_id))
        return result.scalar_one_or_none()

    async def list_by_type(
        self,
        insight_type: InsightType,
        status: InsightStatus | None = None,
        limit: int = 50,
        offset: int = 0,
    ) -> list[Insight]:
        """List insights by type.

        Args:
            insight_type: Filter by insight type
            status: Optional status filter
            limit: Max results
            offset: Skip results

        Returns:
            List of insights
        """
        query = select(Insight).where(Insight.type == insight_type)

        if status:
            query = query.where(Insight.status == status)

        query = query.order_by(Insight.created_at.desc()).limit(limit).offset(offset)

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_by_status(
        self,
        status: InsightStatus,
        limit: int = 50,
        offset: int = 0,
    ) -> list[Insight]:
        """List insights by status.

        Args:
            status: Status filter
            limit: Max results
            offset: Skip results

        Returns:
            List of insights
        """
        query = (
            select(Insight)
            .where(Insight.status == status)
            .order_by(Insight.created_at.desc())
            .limit(limit)
            .offset(offset)
        )
        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_pending(self, limit: int = 50) -> list[Insight]:
        """List pending insights awaiting review.

        Args:
            limit: Max results

        Returns:
            List of pending insights
        """
        return await self.list_by_status(InsightStatus.PENDING, limit)

    async def list_by_entity(
        self,
        entity_id: str,
        status: InsightStatus | None = None,
        limit: int = 50,
    ) -> list[Insight]:
        """List insights related to a specific entity.

        Args:
            entity_id: Entity ID to search for
            status: Optional status filter
            limit: Max results

        Returns:
            List of insights related to the entity
        """
        # JSON array contains query - PostgreSQL specific
        query = select(Insight).where(Insight.entities.contains([entity_id]))

        if status:
            query = query.where(Insight.status == status)

        query = query.order_by(Insight.created_at.desc()).limit(limit)

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_high_confidence(
        self,
        min_confidence: float = 0.8,
        status: InsightStatus | None = None,
        limit: int = 50,
    ) -> list[Insight]:
        """List high-confidence insights.

        Args:
            min_confidence: Minimum confidence threshold
            status: Optional status filter
            limit: Max results

        Returns:
            List of high-confidence insights
        """
        query = select(Insight).where(Insight.confidence >= min_confidence)

        if status:
            query = query.where(Insight.status == status)

        query = query.order_by(Insight.confidence.desc()).limit(limit)

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_by_impact(
        self,
        impact: str,
        status: InsightStatus | None = None,
        limit: int = 50,
    ) -> list[Insight]:
        """List insights by impact level.

        Args:
            impact: Impact level (low, medium, high, critical)
            status: Optional status filter
            limit: Max results

        Returns:
            List of insights with specified impact
        """
        query = select(Insight).where(Insight.impact == impact)

        if status:
            query = query.where(Insight.status == status)

        query = query.order_by(Insight.created_at.desc()).limit(limit)

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_recent(
        self,
        hours: int = 24,
        status: InsightStatus | None = None,
        limit: int = 50,
    ) -> list[Insight]:
        """List recent insights.

        Args:
            hours: Look back period in hours
            status: Optional status filter
            limit: Max results

        Returns:
            List of recent insights
        """
        cutoff = datetime.now(UTC) - timedelta(hours=hours)

        query = select(Insight).where(Insight.created_at >= cutoff)

        if status:
            query = query.where(Insight.status == status)

        query = query.order_by(Insight.created_at.desc()).limit(limit)

        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def list_all(
        self,
        limit: int = 100,
        offset: int = 0,
    ) -> list[Insight]:
        """List all insights.

        Args:
            limit: Max results
            offset: Skip results

        Returns:
            List of insights
        """
        query = select(Insight).order_by(Insight.created_at.desc()).limit(limit).offset(offset)
        result = await self.session.execute(query)
        return list(result.scalars().all())

    async def mark_reviewed(self, insight_id: str) -> Insight | None:
        """Mark insight as reviewed.

        Args:
            insight_id: Insight UUID

        Returns:
            Updated insight or None
        """
        insight = await self.get_by_id(insight_id)
        if insight:
            insight.mark_reviewed()
            await self.session.flush()
        return insight

    async def mark_actioned(self, insight_id: str) -> Insight | None:
        """Mark insight as actioned.

        Args:
            insight_id: Insight UUID

        Returns:
            Updated insight or None
        """
        insight = await self.get_by_id(insight_id)
        if insight:
            insight.mark_actioned()
            await self.session.flush()
        return insight

    async def dismiss(self, insight_id: str) -> Insight | None:
        """Dismiss an insight.

        Args:
            insight_id: Insight UUID

        Returns:
            Updated insight or None
        """
        insight = await self.get_by_id(insight_id)
        if insight:
            insight.dismiss()
            await self.session.flush()
        return insight

    async def update_evidence(
        self,
        insight_id: str,
        evidence: dict[str, Any],
        merge: bool = True,
    ) -> Insight | None:
        """Update insight evidence.

        Args:
            insight_id: Insight UUID
            evidence: New evidence data
            merge: If True, merge with existing; if False, replace

        Returns:
            Updated insight or None
        """
        insight = await self.get_by_id(insight_id)
        if insight:
            if merge and insight.evidence:
                insight.evidence = {**insight.evidence, **evidence}
            else:
                insight.evidence = evidence
            await self.session.flush()
        return insight

    async def count(
        self,
        type: InsightType | None = None,
        status: InsightStatus | None = None,
    ) -> int:
        """Count insights.

        Args:
            type: Optional type filter
            status: Optional status filter

        Returns:
            Count of insights
        """
        query = select(func.count(Insight.id))

        if type:
            query = query.where(Insight.type == type)
        if status:
            query = query.where(Insight.status == status)

        result = await self.session.execute(query)
        return result.scalar() or 0

    async def count_by_type(self) -> dict[str, int]:
        """Get insight counts grouped by type.

        Returns:
            Dict of type -> count
        """
        query = select(Insight.type, func.count(Insight.id)).group_by(Insight.type)
        result = await self.session.execute(query)
        return {row[0].value: row[1] for row in result.all()}

    async def count_by_status(self) -> dict[str, int]:
        """Get insight counts grouped by status.

        Returns:
            Dict of status -> count
        """
        query = select(Insight.status, func.count(Insight.id)).group_by(Insight.status)
        result = await self.session.execute(query)
        return {row[0].value: row[1] for row in result.all()}

    async def count_by_impact(self, *impacts: str) -> int:
        """Count insights matching any of the given impact levels.

        Args:
            impacts: Impact level strings (e.g. "high", "critical")

        Returns:
            Total count across all specified levels
        """
        query = select(func.count(Insight.id)).where(Insight.impact.in_(impacts))
        result = await self.session.execute(query)
        return result.scalar() or 0

    async def get_summary(self) -> dict[str, Any]:
        """Get aggregated insight summary in a single DB round-trip.

        Returns a dict with total, by_type, by_status, pending_count,
        and high_impact_count.
        """
        total_q = select(func.count(Insight.id))
        type_q = select(Insight.type, func.count(Insight.id)).group_by(Insight.type)
        status_q = select(Insight.status, func.count(Insight.id)).group_by(Insight.status)
        impact_q = select(func.count(Insight.id)).where(Insight.impact.in_(("high", "critical")))

        total_r, type_r, status_r, impact_r = (
            await self.session.execute(total_q),
            await self.session.execute(type_q),
            await self.session.execute(status_q),
            await self.session.execute(impact_q),
        )

        by_status = {row[0].value: row[1] for row in status_r.all()}

        return {
            "total": total_r.scalar() or 0,
            "by_type": {row[0].value: row[1] for row in type_r.all()},
            "by_status": by_status,
            "pending_count": by_status.get(InsightStatus.PENDING.value, 0),
            "high_impact_count": impact_r.scalar() or 0,
        }

    async def delete(self, insight_id: str) -> bool:
        """Delete an insight.

        Args:
            insight_id: Insight UUID

        Returns:
            True if deleted, False if not found
        """
        insight = await self.get_by_id(insight_id)
        if insight:
            await self.session.delete(insight)
            await self.session.flush()
            return True
        return False

    async def get_by_mlflow_run(self, mlflow_run_id: str) -> list[Insight]:
        """Get insights by MLflow run ID.

        Args:
            mlflow_run_id: MLflow run ID

        Returns:
            List of insights from that run
        """
        query = (
            select(Insight)
            .where(Insight.mlflow_run_id == mlflow_run_id)
            .order_by(Insight.created_at)
        )
        result = await self.session.execute(query)
        return list(result.scalars().all())
